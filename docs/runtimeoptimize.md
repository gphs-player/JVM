## 运行期优化



### 即时编译器

#### 1.热点代码对象

* 多次执行的方法
* 多次执行的循环体，也以整个方法作为编译，称为栈上替换（OSR）

#### 2.触发条件

即时编译触发条件是进行热点探测

* 基于采样的热点探测，周期性查看线程的栈顶，如果方法经常出现在栈顶就是热点代码。容易获取方法调用关系，但是准确性会受影响
* 基于计数器，为每个方法建立计数器，超出阈值就是热点代码，统计结果准确，但是不能获取调用关系。
  * 方法计数器
  * 回边计数器

### 编译优化技术

语言无关的经典优化技术之一：公共子表达式消除

语言相关的经典优化技术之一：数组范围检查消除

最重要的优化技术之一：方法内联

最前沿的优化技术之一：逃逸分析

#### 1.公共子表达式消除

如果一个表达式E已经被计算过了，并且E中所有的变量都没有变化过，那么E的这次出现就是公共子表达式。

举例：

`int d=（c*b）*12+a+（a+b*c）`

javac编译器不会进行优化，但是虚拟机的即时编译器会进行优化

编译器检测到`c*b`与`b*c`是一样的表达式，而且在计算期间b与c的值是不变的。因此这条表达式就可能被视为：

`int d=E*12+a+（a+E）；`

这时候，编译器还可能进行另外一种优化：代数化简（Algebraic Simplification），把表达式变为：

`int d=E*13+a*2；`

#### 2.数组边界检查消除

数组边界检查肯定是必须做的，但数组边界检查是不是必须在运行期间一次不漏地检查则是可以“商量”的事情,编译器只要通过数据流分析就可以判定循环变量的取值范围永远在区间[0，foo.length）之内，那在整个循环中就可以把数组的上下界检查消除掉，这可以节省很多次的条件判断操作。

类似的优化还有自动装箱消除，消除反射，安全点消除等。

#### 3.方法内联

最重要的优化手段之一，除了消除方法调用的成本之外，它更重要的意义是为其他优化手段建立良好的基础，

如下面代码所示的例子就揭示了内联对其他优化手段的意义：事实上testInline（）方法的内部全部都是无用的代码，如果不做内联，后续即使进行了无用代码消除的优化，也无法发现任何“Dead Code”，因为如果分开来看，foo（）和testInline（）两个方法里面的操作都可能是有意义的。

```java
public static void foo(Object obj){
	if(obj！=null){
		System.out.println("do something");
	}
}
public static void testInline(String[]args){
	Object obj=null；
	foo(obj)；
}
```



#### 4.逃逸分析

对象是分配在堆中，一个方法中的对象可以被其他方法甚至其他线程使用，这种情况叫做方法逃逸和线程逃逸。如果一个对象没有方法逃逸和线程逃逸，可以做以下优化：

* 栈上分配：让对象占用空间随着栈的销毁而销毁。一般应用不会逃逸的对象比重很大。
* 同步消除：同步是一个耗时操作，如果不会线程逃逸，同步措施就可以消除。
* 标量替换：不可分解的int、char等类型叫做标量，如果一个对象可以被分解叫做聚合量（如对象）。假如一个对象不会被外部访问，并且可以拆散的话，可能就不会实例化这个对象，而是创建若干个成员变量来替换。