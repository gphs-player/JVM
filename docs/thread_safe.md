## 线程安全与锁优化



### 一、线程安全类型

Java中操作共享数据类型分为以下5类：

#### 1.不可变类型

不可变（Immutable）对象一定是线程安全的。比如String就是典型的不可变对象。还有枚举，Number的部分子类。

#### 2.绝对线程安全

“不管运行时环境如何，调用者都不需要任何额外的同步措施”，但是：

虽然一个类所有的方法都是同步的，但是并不意味着不需要同步措施

```java
public class VectorTest {
    private static Vector<Integer> vector = new Vector<>();
    public static void main(String [] args){
        while (true){
            for (int i = 0; i < 10; i++) {
                vector.add(i);
            }
            Thread removeThread = new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < vector.size(); i++) {
                        System.out.println("removeThread删除");
                        vector.remove(i);
                    }
                }
            });
            Thread printThread = new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < vector.size(); i++) {
                        System.out.println(vector.get(i));
                    }
                }
            });
            removeThread.start();
            printThread.start();
            while (Thread.activeCount() > 30){
                //不要产生过多的线程
            }
        }
    }
}
```

上述例子还是会抛出ArrayIndexOutOfBoundsException异常的

解决措施还是要添加同步锁

```java
synchronized (vector) {
    for (int i = 0; i < vector.size(); i++) {
        System.out.println("removeThread删除");
        vector.remove(i);
    }
}
```

#### 3.相对线程安全

相对的线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。上述代码就是相对线程安全的一个很明显的案例。

在Java语言中，大部分的线程安全类都属于这种类型，例如Vector、HashTable、Collections的synchronizedCollection（）方法包装的集合等。

#### 4.线程兼容

线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中安全地使用，我们平常说一个类不是线程安全的，绝大多数指的都是这种情况。Java API中大部分的类都是线程兼容的，如与前面的Vector和HashTable相对应的集合类ArrayList和HashMap等。

#### 5.线程对立

线程对立是指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于Java语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。



### 二、线程安全方法

#### 1.互斥同步

同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条（或者是一些，使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。

##### **synchronized关键字**

编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，它们都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。

在执行monitorenter指令时，首先要去尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应地，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放了。如果获取对象锁失败了，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。

##### **ReentrantLock**

和synchronized的区别表现为API层面的互斥锁（lock（）和unlock（）方法配合try/finally语句块来完成）

增加了以下高级功能

* 等待可中断，正在等待的线程迟迟获取不到资源的时候可以选择放弃等待，做其它的事情。
* 公平锁，多个线程在等待资源的时候，必须按照申请锁的时间顺序来依次获得锁。ReentrantLock默认是非公平的，通过布尔值的构造指定，synchronized是非公平的。
* 锁绑定多个条件，可以同时绑定多个condition对象，synchronized只能多添加一个锁实现。

##### **问题**

也被称为阻塞同步，是一种悲观的并发策略，线程阻塞和唤醒有性能问题。

#### 2.非阻塞同步

典型的是CAS（Compare and Swap）

基于冲突检测的乐观并发策略，通俗地说就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再进行其他的补偿措施（最常见的补偿措施就是不断地重试，直到试成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作被称为非阻塞同步（Non-Blocking Synchronization）。

CAS指令需要有三个操作数，分别是内存位置（在Java中可以简单理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和新值（用B表示）。CAS指令执行时，当且仅当V符合旧预期值A时，处理器用新值B更新V的值，否则它就不执行更新，但是不管是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作。

##### **ABA问题**

举例：银行卡里有100块钱，我要取50，两条线程A和B去执行操作，A执行成功，在B执行之前有线程C进来存50，然后线程B才开始执行。线程B判断初始值是100，所以会继续进行操作。这样最终的结果就出现异常。

#### 3、无同步方案

如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的

##### **可重入代码**

例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。我们可以通过一个简单一些的原则来判断代码是否具备可重入性：如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。

##### **线程本地存储**

共享数据保证在一个线程内部执行，例如volatile和ThreadLocal类



### 三、锁优化

#### 1.自旋锁与适应性自旋锁

共享数据的锁定状态大部分情况下只会持续很短的时间，不一定非得挂起线程再恢复线程。可以让请求锁的线程“稍等一会”，看看持有锁资源的线程是不是很快会释放锁。让线程等待需要让线程执行一个忙循环（默认10次），这就是自选。

如果线程占用的时间很短，自选效果就很好，反之则会耗费处理器资源。

JDK1.6引入了适应性自旋，如果在同一个锁对象上，自旋获得过成功，虚拟机认为这次自旋也很有可能会成功，自旋的次数会允许增加。如果自旋很少成功，那么就会缩减自旋次数甚至省略自旋过程。



#### 2.锁消除

虚拟机即时编译器对在代码上要求同步，但是被检测到不存在共享数据竞争的锁进行的消除。判断依据来自逃逸分析，不会逃逸的数据会被当做栈上数据对待，同步的加锁操作也就没必要。

```java
public String contactStr(String s1,String s2,String s3){
    return s1+s2+s3;
}
```

上述代码使用StringBuilder实现的，在1.5以前用的是StringBUffer的append方法，在这里就会判断没有同步的必要。



#### 3.锁粗化

原则上会将同步块的范围尽可能缩小，这样存在锁竞争的话，那等待锁资源的线程也能很快获得资源。

但是如果一连串的操作反复对同一个对象加锁和解锁，甚至加锁操作出现在循环中，那么即使没有线程竞争，也是很大的损耗。比如上面一串的append方法。这个时候虚拟机会把整个锁的范围扩展（粗化）到整个操作的序列外部，比如第一个append之前到最后一个append之后，这样只需加锁一次即可。



#### 4.轻量级锁

虚拟机的对象头（Object Header）分为两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄（Generational GC Age）等，这部分数据的长度在32位和64位的虚拟机中分别为32个和64个Bits，官方称它为“Mark Word”，另外一部分用于存储指向方法区对象类型数据的指针，如果是数组对象的话，还会有一个额外的部分用于存储数组长度。

在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word），这时候线程堆栈与对象头的状态如图13-3所示。

然后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位（Mark Word的最后两个Bits）将转变为“00”，即表示此对象处于轻量级锁定的状态

如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。

#### 5.偏向锁

在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。

锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。

当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。
